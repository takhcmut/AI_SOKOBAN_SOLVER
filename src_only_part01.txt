Folder src
File __init__.py
# Contents of the file: /sokoban-python/sokoban-python/src/sokoban/__init__.py

# This file is intentionally left blank.

File async_solver.py
# -*- coding: utf-8 -*-
import threading, time, queue
from dataclasses import dataclass
from typing import Callable, Optional, List, Tuple, Any

ProgressCB = Callable[[int, float], None]  # (expanded, elapsed_sec)

@dataclass
class SolverResult:
    ok: bool
    path: Optional[List[str]]
    expanded: int
    elapsed: float
    reason: str = ""

class AsyncSolver:
    """Chạy solver trong thread phụ để UI không bị 'Not Responding'."""
    def __init__(self):
        self._th = None
        self._running = False
        self._lock = threading.Lock()
        self.cancel_event = threading.Event()
        self.progress_q: "queue.Queue[Tuple[int,float]]" = queue.Queue()
        self.result: Optional[SolverResult] = None
        self._expanded_snapshot = 0

    def is_running(self) -> bool:
        with self._lock:
            return self._running

    def start(self, solve_func: Callable[..., Any], state, algo: str, heuristic: str):
        if self.is_running():
            return False
        self.cancel_event.clear()
        self.result = None
        self._expanded_snapshot = 0

        def progress_cb(expanded: int, elapsed: float):
            self._expanded_snapshot = expanded
            try: self.progress_q.put_nowait((expanded, elapsed))
            except queue.Full: pass

        def worker():
            t0 = time.time()
            try:
                path = solve_func(state, algo, heuristic, self.cancel_event, progress_cb)
                elapsed = time.time() - t0
                ok = bool(path)
                self.result = SolverResult(
                    ok=ok, path=path if ok else None,
                    expanded=self._expanded_snapshot, elapsed=elapsed,
                    reason="" if ok else ("canceled" if self.cancel_event.is_set() else "no-solution"),
                )
            except Exception as e:
                elapsed = time.time() - t0
                self.result = SolverResult(False, None, self._expanded_snapshot, elapsed, f"error: {e}")
            finally:
                with self._lock:
                    self._running = False

        with self._lock:
            self._running = True
        self._th = threading.Thread(target=worker, daemon=True)
        self._th.start()
        return True

    def cancel(self):
        self.cancel_event.set()

    def poll_progress(self):
        try:
            return self.progress_q.get_nowait()
        except queue.Empty:
            return None

File deadlock_detector.py
from point import Point


class DeadLockDetector:
    def __init__(self, sokoban):
        self.soku = sokoban
        self.walls = self.soku.get_walls()
        self.storages = self.soku.get_storages()
        self.width = self.soku.get_width()
        self.height = self.soku.get_height()
        self.map = [[' ' for _ in range(self.width)] for _ in range(self.height)]
        self.deadlocks = set()
        self.load_map()

    def find_deadlock(self):
        for i in range(1, self.height + 1):
            for j in range(1, self.width + 1):
                current = Point(i, j)
                if current not in self.walls and current not in self.storages:
                    if self.corner_test(current):
                        self.deadlocks.add(current)
                        self.map[i - 1][j - 1] = '^'
                    elif self.boundary_test(current):
                        self.deadlocks.add(current)
                        self.map[i - 1][j - 1] = '?'

    def load_map(self):
        for e in self.walls:
            self.map[e.get_x() - 1][e.get_y() - 1] = '#'
        for e in self.storages:
            self.map[e.get_x() - 1][e.get_y() - 1] = '!'
        for e in self.soku.get_boxes():
            self.map[e.get_x() - 1][e.get_y() - 1] = '@'
        self.map[self.soku.get_player().get_x() - 1][self.soku.get_player().get_y() - 1] = '*'

    def print_map(self):
        for row in self.map:
            print(' '.join(row))

    def corner_test(self, current):
        up = self.get_up_neighbor(current)
        down = self.get_down_neighbor(current)
        right = self.get_right_neighbor(current)
        left = self.get_left_neighbor(current)

        return ((up in self.walls and right in self.walls) or
                (up in self.walls and left in self.walls) or
                (down in self.walls and left in self.walls) or
                (down in self.walls and right in self.walls))

    def boundary_test(self, current):
        x = current.get_x()
        y = current.get_y()

        if self.get_left_neighbor(current) in self.walls:
            upbound = self.find_nearest_upbound(current)
            downbound = self.find_nearest_downbound(current)

            if upbound == -1 or downbound == -1:
                return False
            else:
                for m in range(upbound + 1, downbound):
                    b = Point(m, y - 1)
                    if b not in self.walls:
                        return False
                return True

        if self.get_right_neighbor(current) in self.walls:
            upbound = self.find_nearest_upbound(current)
            downbound = self.find_nearest_downbound(current)

            if upbound == -1 or downbound == -1:
                return False
            else:
                for m in range(upbound + 1, downbound):
                    b = Point(m, y + 1)
                    if b not in self.walls:
                        return False
                return True

        if self.get_up_neighbor(current) in self.walls:
            rightbound = self.find_nearest_rightbound(current)
            leftbound = self.find_nearest_leftbound(current)

            if leftbound == -1 or rightbound == -1:
                return False
            else:
                for m in range(leftbound + 1, rightbound):
                    b = Point(x - 1, m)
                    if b not in self.walls:
                        return False
                return True

        if self.get_down_neighbor(current) in self.walls:
            rightbound = self.find_nearest_rightbound(current)
            leftbound = self.find_nearest_leftbound(current)

            if leftbound == -1 or rightbound == -1:
                return False
            else:
                for m in range(leftbound + 1, rightbound):
                    b = Point(x + 1, m)
                    if b not in self.walls:
                        return False
                return True

        return False

    def get_right_neighbor(self, current):
        return Point(current.get_x(), current.get_y() + 1)

    def get_left_neighbor(self, current):
        return Point(current.get_x(), current.get_y() - 1)

    def get_up_neighbor(self, current):
        return Point(current.get_x() - 1, current.get_y())

    def get_down_neighbor(self, current):
        return Point(current.get_x() + 1, current.get_y())

    def find_nearest_upbound(self, a):
        y = a.get_y()
        x = a.get_x() - 1

        while x >= 0:
            temp = Point(x, y)
            if temp in self.walls:
                return x
            elif temp in self.storages:
                return -1
            x -= 1
        return 0

    def find_nearest_downbound(self, a):
        y = a.get_y()
        x = a.get_x() + 1

        while x < self.height:
            temp = Point(x, y)
            if temp in self.walls:
                return x
            elif temp in self.storages:
                return -1
            x += 1
        return self.height

    def find_nearest_rightbound(self, a):
        y = a.get_y() + 1
        x = a.get_x()

        while y < self.width:
            temp = Point(x, y)
            if temp in self.walls:
                return y
            elif temp in self.storages:
                return -1
            y += 1
        return self.width

    def find_nearest_leftbound(self, a):
        y = a.get_y() - 1
        x = a.get_x()

        while y >= 0:
            temp = Point(x, y)
            if temp in self.walls:
                return y
            elif temp in self.storages:
                return -1
            y -= 1
        return 0

    def get_deadlock(self):
        self.find_deadlock()
        return set(self.deadlocks)

    def __str__(self):
        return ' '.join(str(e) for e in self.deadlocks)

File map_parser.py
class MapParser:
    def __init__(self, filename):
        with open(filename, 'r') as file:
            lines = file.readlines()
        
        self.row = len(lines)
        self.col = len(lines[0].strip())
        self.map = [list(line.strip()) for line in lines]

    def parse(self):
        print(f"{self.col} {self.row}")

        numWalls = 0
        numBoxes = 0
        numStorages = 0
        walls = []
        boxes = []
        storages = []
        pos = []

        for i in range(self.row):
            for j in range(self.col):
                if self.map[i][j] == '#':
                    walls.append(i + 1)
                    walls.append(j + 1)
                    numWalls += 1
                elif self.map[i][j] == '$':
                    boxes.append(i + 1)
                    boxes.append(j + 1)
                    numBoxes += 1
                elif self.map[i][j] == '.':
                    storages.append(i + 1)
                    storages.append(j + 1)
                    numStorages += 1
                elif self.map[i][j] == '@':
                    pos.append(i + 1)
                    pos.append(j + 1)

        print(numWalls, " ".join(map(str, walls)))
        print(numBoxes, " ".join(map(str, boxes)))
        print(numStorages, " ".join(map(str, storages)))
        print(" ".join(map(str, pos)))

File point.py
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def get_x(self):
        return self.x

    def get_y(self):
        return self.y

    def __hash__(self):
        return self.x * 31 + self.y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return False

    def __str__(self):
        return f"Point({self.x},{self.y}):{hash(self)}"

File search.py
# -*- coding: utf-8 -*-
"""
Search algorithms for Sokoban.

- Giữ nguyên thuật toán gốc (BFS/DFS/IDS/UCS/Greedy/A*) và các biến thể
  *_return_path(...) trả về chuỗi move.
- Thêm hỗ trợ HỦY trong nền: tham số tùy chọn `stop_cb` (callable -> bool).
  Khi `stop_cb()` trả về True, thuật toán lập tức kết thúc và trả về [].
- Tối ưu:
  • BFS dùng deque và đánh dấu visited NGAY khi enqueue.
  • UCS/A* dùng best_g (cost-so-far) để tránh đẩy trạng thái tệ hơn.
  • Vòng lặp kiểm tra hủy theo chu kỳ để giảm overhead (CHECK_EVERY).
- Tương thích UI hiện tại: A* nhận heuristic "manhatten" hoặc "euclidean".
"""
from __future__ import annotations

import heapq
import time
import itertools
from collections import deque
from typing import Callable, Iterable, List, Optional


StopFn = Optional[Callable[[], bool]]


class Search:
    def __init__(self, verbose: bool = False):
        self.verbose = verbose
        # kiểm tra hủy mỗi N node để tiết kiệm chi phí hàm gọi
        self.CHECK_EVERY = 2048

    # ---------------------- tiện ích nội bộ ----------------------
    def _should_stop(self, expanded: int, stop_cb: StopFn) -> bool:
        try:
            return bool(stop_cb and expanded % self.CHECK_EVERY == 0 and stop_cb())
        except Exception:
            # nếu callback lỗi, coi như không hủy
            return False

    # ====================== NON-RETURN (in-place print) ======================

    def bfs(self, state, stop_cb: StopFn = None):
        start_time = time.time()
        q = deque([state])
        visited = {state}
        expanded = 0

        while q:
            curr = q.popleft()
            if curr.reached_goal():
                print("**************** Solution Found ! ******************")
                print(len(curr.get_move()))
                print("bfs: {:.2f} ms".format((time.time() - start_time) * 1000))
                break

            for e in curr.get_neighbors():
                if e not in visited:
                    visited.add(e)
                    q.append(e)

            expanded += 1
            if self._should_stop(expanded, stop_cb):
                break

    def dfs(self, state, stop_cb: StopFn = None):
        start_time = time.time()
        stack = [state]
        visited = {state}
        expanded = 0

        while stack:
            curr = stack.pop()
            if curr.reached_goal():
                print("**************** Solution Found ! ******************")
                print(len(curr.get_move()))
                print("dfs: {:.2f} ms".format((time.time() - start_time) * 1000))
                break

            for e in curr.get_neighbors():
                if e not in visited:
                    visited.add(e)
                    stack.append(e)

            expanded += 1
            if self._should_stop(expanded, stop_cb):
                break

    def ids(self, state, stop_cb: StopFn = None, depth_step: int = 10, max_limit: int = 500):
        start_time = time.time()
        limit = 50

        while limit <= max_limit:
            stack = [state]
            visited = {state}
            expanded = 0

            while stack:
                curr = stack.pop()
                if curr.reached_goal():
                    print("**************** Solution Found ! ******************")
                    print(len(curr.get_move()))
                    print("ids: {:.2f} ms".format((time.time() - start_time) * 1000))
                    return

                for e in curr.get_neighbors():
                    if e not in visited and len(e.get_move()) <= limit:
                        visited.add(e)
                        stack.append(e)

                expanded += 1
                if self._should_stop(expanded, stop_cb):
                    return
            limit += depth_step

    def ucs(self, state, stop_cb: StopFn = None):
        start_time = time.time()
        pq = []
        counter = itertools.count()
        heapq.heappush(pq, (0, next(counter), state))
        best_g = {state: 0}
        expanded = 0

        while pq:
            g, _, curr = heapq.heappop(pq)
            if curr.reached_goal():
                print("**************** Solution Found ! ******************")
                print(len(curr.get_move()))
                print("ucs: {:.2f} ms".format((time.time() - start_time) * 1000))
                break

            for e in curr.get_neighbors():
                g2 = len(e.get_move())
                if e not in best_g or g2 < best_g[e]:
                    best_g[e] = g2
                    heapq.heappush(pq, (g2, next(counter), e))

            expanded += 1
            if self._should_stop(expanded, stop_cb):
                break

    def greedy(self, state, heuristic, stop_cb: StopFn = None):
        start_time = time.time()
        pq = []
        counter = itertools.count()

        def h(s):
            if heuristic == "euclidean":
                return s.euclidean()
            elif heuristic == "manhatten":
                return s.manhatten()
            return 0

        heapq.heappush(pq, (h(state), next(counter), state))
        visited = {state}
        expanded = 0

        while pq:
            _, _, curr = heapq.heappop(pq)
            if curr.reached_goal():
                print("**************** Solution Found ! ******************")
                print(len(curr.get_move()))
                print("greedy({}): {:.2f} ms".format(heuristic, (time.time() - start_time) * 1000))
                break

            for e in curr.get_neighbors():
                if e not in visited:
                    visited.add(e)
                    heapq.heappush(pq, (h(e), next(counter), e))

            expanded += 1
            if self._should_stop(expanded, stop_cb):
                break

    def astar(self, state, heuristic, stop_cb: StopFn = None):
        start_time = time.time()
        pq = []
        counter = itertools.count()

        def h(s):
            if heuristic == "euclidean":
                return s.euclidean()
            elif heuristic == "manhatten":
                return s.manhatten()
            return 0

        heapq.heappush(pq, (0, next(counter), state))
        best_g = {state: 0}
        expanded = 0

        while pq:
            _, _, curr = heapq.heappop(pq)
            if curr.reached_goal():
                print("**************** Solution Found ! ******************")
                print(len(curr.get_move()))
                print("A* ({}): {:.2f} ms".format(heuristic, (time.time() - start_time) * 1000))
                break

            g = len(curr.get_move())
            for e in curr.get_neighbors():
                g2 = g + 1
                if e not in best_g or g2 < best_g[e]:
                    best_g[e] = g2
                    f = g2 + h(e)
                    heapq.heappush(pq, (f, next(counter), e))

            expanded += 1
            if self._should_stop(expanded, stop_cb):
                break

    # ======================= RETURN PATH VERSIONS =======================

    def bfs_return_path(self, state, stop_cb: StopFn = None) -> List[str]:
        start_time = time.time()
        q = deque([state])
        visited = {state}
        expanded = 0

        while q:
            curr = q.popleft()
            if curr.reached_goal():
                print("**************** Solution Found ! ******************")
                print(len(curr.get_move()))
                print("bfs: {:.2f} ms".format((time.time() - start_time) * 1000))
                return list(curr.get_move())

            for e in curr.get_neighbors():
                if e not in visited:
                    visited.add(e)
                    q.append(e)

            expanded += 1
            if self._should_stop(expanded, stop_cb):
                return []
        return []

    def dfs_return_path(self, state, stop_cb: StopFn = None) -> List[str]:
        start_time = time.time()
        stack = [state]
        visited = {state}
        expanded = 0

        while stack:
            curr = stack.pop()
            if curr.reached_goal():
                print("**************** Solution Found ! ******************")
                print(len(curr.get_move()))
                print("dfs: {:.2f} ms".format((time.time() - start_time) * 1000))
                return list(curr.get_move())

            for e in curr.get_neighbors():
                if e not in visited:
                    visited.add(e)
                    stack.append(e)

            expanded += 1
            if self._should_stop(expanded, stop_cb):
                return []
        return []

    def ids_return_path(
        self,
        state,
        stop_cb: StopFn = None,
        depth_step: int = 10,
        max_limit: int = 500
    ) -> List[str]:
        start_time = time.time()
        limit = 50

        while limit <= max_limit:
            stack = [state]
            visited = {state}
            expanded = 0

            while stack:
                curr = stack.pop()
                if curr.reached_goal():
                    print("**************** Solution Found ! ******************")
                    print(len(curr.get_move()))
                    print("ids: {:.2f} ms".format((time.time() - start_time) * 1000))
                    return list(curr.get_move())

                for e in curr.get_neighbors():
                    if e not in visited and len(e.get_move()) <= limit:
                        visited.add(e)
                        stack.append(e)

                expanded += 1
                if self._should_stop(expanded, stop_cb):
                    return []
            limit += depth_step
        return []

    def ucs_return_path(self, state, stop_cb: StopFn = None) -> List[str]:
        start_time = time.time()
        pq = []
        counter = itertools.count()
        heapq.heappush(pq, (0, next(counter), state))
        best_g = {state: 0}
        expanded = 0

        while pq:
            g, _, curr = heapq.heappop(pq)
            if curr.reached_goal():
                print("**************** Solution Found ! ******************")
                print(len(curr.get_move()))
                print("ucs: {:.2f} ms".format((time.time() - start_time) * 1000))
                return list(curr.get_move())

            for e in curr.get_neighbors():
                g2 = len(e.get_move())
                if e not in best_g or g2 < best_g[e]:
                    best_g[e] = g2
                    heapq.heappush(pq, (g2, next(counter), e))

            expanded += 1
            if self._should_stop(expanded, stop_cb):
                return []
        return []

    def greedy_return_path(self, state, heuristic, stop_cb: StopFn = None) -> List[str]:
        start_time = time.time()
        pq = []
        counter = itertools.count()

        def h(s):
            if heuristic == "euclidean":
                return s.euclidean()
            elif heuristic == "manhatten":
                return s.manhatten()
            return 0

        heapq.heappush(pq, (h(state), next(counter), state))
        visited = {state}
        expanded = 0

        while pq:
            _, _, curr = heapq.heappop(pq)
            if curr.reached_goal():
                print("**************** Solution Found ! ******************")
                print(len(curr.get_move()))
                print("greedy({}): {:.2f} ms".format(heuristic, (time.time() - start_time) * 1000))
                return list(curr.get_move())

            for e in curr.get_neighbors():
                if e not in visited:
                    visited.add(e)
                    heapq.heappush(pq, (h(e), next(counter), e))

            expanded += 1
            if self._should_stop(expanded, stop_cb):
                return []
        return []

    def astar_return_path(self, state, heuristic, stop_cb: StopFn = None) -> List[str]:
        start_time = time.time()
        pq = []
        counter = itertools.count()

        def h(s):
            if heuristic == "euclidean":
                return s.euclidean()
            elif heuristic == "manhatten":
                return s.manhatten()
            return 0

        heapq.heappush(pq, (0, next(counter), state))
        best_g = {state: 0}
        expanded = 0

        while pq:
            _, _, curr = heapq.heappop(pq)
            if curr.reached_goal():
                print("**************** Solution Found ! ******************")
                print(len(curr.get_move()))
                print("A* ({}): {:.2f} ms".format(heuristic, (time.time() - start_time) * 1000))
                return list(curr.get_move())

            g = len(curr.get_move())
            for e in curr.get_neighbors():
                g2 = g + 1
                if e not in best_g or g2 < best_g[e]:
                    best_g[e] = g2
                    f = g2 + h(e)
                    heapq.heappush(pq, (f, next(counter), e))

            expanded += 1
            if self._should_stop(expanded, stop_cb):
                return []
        return []

File sokoban.py
from point import Point


class Sokoban:
    def __init__(self, filename):
        self.walls = set()
        self.storages = set()
        self.boxes = set()
        self.read_input(filename)
        self.load_map()

    def read_input(self, filename):
        with open(filename, 'r') as file:
            sizes = file.readline().strip().split()
            n_walls = file.readline().strip().split()
            n_boxes = file.readline().strip().split()
            n_storages = file.readline().strip().split()
            pos = file.readline().strip().split()

            # Handle sizes
            self.width = int(sizes[0])
            self.height = int(sizes[1])

            # Handle objects
            self.load(n_walls, self.walls, "walls")
            self.load(n_boxes, self.boxes, "boxes")
            self.load(n_storages, self.storages, "storages")

            # Handle player
            self.player = Point(int(pos[0]), int(pos[1]))

    def load(self, arr, hst, name):
        num = int(arr[0]) - 1
        for i in range(num):
            hst.add(Point(int(arr[2 * i + 1]), int(arr[2 * i + 2])))

    def load_map(self):
        self.map = [[' ' for _ in range(self.width)] for _ in range(self.height)]
        for e in self.walls:
            self.map[e.get_x() - 1][e.get_y() - 1] = '#'
        for e in self.boxes:
            self.map[e.get_x() - 1][e.get_y() - 1] = '$'
        for e in self.storages:
            self.map[e.get_x() - 1][e.get_y() - 1] = '.'
        self.map[self.player.get_x() - 1][self.player.get_y() - 1] = '@'

    def print_map(self):
        print("-------------Initial Map---------------------")
        print("The map is as follows:")
        for row in self.map:
            print(' '.join(row))

    def get_width(self):
        return self.width

    def set_width(self, width):
        self.width = width

    def get_height(self):
        return self.height

    def set_height(self, height):
        self.height = height

    def get_walls(self):
        return self.walls

    def set_walls(self, walls):
        self.walls = walls

    def get_storages(self):
        return self.storages

    def set_storages(self, storages):
        self.storages = storages

    def get_boxes(self):
        return self.boxes

    def set_boxes(self, boxes):
        self.boxes = boxes

    def get_player(self):
        return self.player

    def set_player(self, player):
        self.player = player

File state.py
# -*- coding: utf-8 -*-
"""
state.py — Trạng thái Sokoban (tọa độ 1-based: x=row, y=col).

- Mục tiêu: biểu diễn nút trạng thái cho BFS/A*, sinh lân cận hợp lệ,
  hash/equality ổn định để dùng trong set/dict, và cung cấp heuristic admissible.

- Thành phần:
  * walls, boxes, storages: set[Point]
  * player: Point
  * move: chuỗi "udlr" từ đầu đến hiện tại (dùng để phát lại lời giải)
  * rows, cols: kích thước bản đồ
  * deadlocks: tập các ô "chết" (đẩy box vào là thua chắc), từ DeadLockDetector

- Heuristic:
  * manhatten(): admissible, nhanh — player→box gần nhất + Σ(box→goal gần nhất)
  * euclidean(): cùng ý tưởng, dùng khoảng cách Euclid (ít được dùng cho A* trong grid với đẩy hộp)

Lưu ý:
- __hash__ phải khớp __eq__: nếu boxes & player giống nhau ⇒ hash giống nhau.
- get_neighbors() KHÔNG làm thay đổi trạng thái gốc (copy set khi cần).
"""

from __future__ import annotations
from typing import Iterable, List, Set, Tuple
from point import Point


class State:
    __slots__ = (
        "walls", "boxes", "storages",
        "player", "move",
        "rows", "cols",
        "verbose", "deadlocks",
        "_neighbors_cache",
    )

    def __init__(
        self,
        walls: Iterable[Point],
        boxes: Iterable[Point],
        storages: Iterable[Point],
        player: Point,
        move: str,
        rows: int,
        cols: int,
        verbose: bool,
        deadlocks: Iterable[Point],
    ) -> None:
        # Sao chép vào set để trạng thái độc lập, tránh side-effect
        self.walls: Set[Point] = set(walls)
        self.boxes: Set[Point] = set(boxes)
        self.storages: Set[Point] = set(storages)
        self.player: Point = player
        self.move: str = move
        self.rows: int = int(rows)
        self.cols: int = int(cols)
        self.verbose: bool = bool(verbose)
        self.deadlocks: Set[Point] = set(deadlocks)
        self._neighbors_cache: List[State] | None = None

    # ------------------------- tiện ích cơ bản -------------------------

    def inbound(self, x: int, y: int) -> bool:
        """Ô (x,y) có nằm trong bản đồ không (1-based)."""
        return 1 <= x <= self.rows and 1 <= y <= self.cols

    def reached_goal(self) -> bool:
        """Tất cả box đều đứng trên goal (cho phép số goal ≥ số box)."""
        return all(b in self.storages for b in self.boxes)

    def get_move(self) -> str:
        return self.move

    def get_player(self) -> Point:
        return self.player

    def get_boxes(self) -> Set[Point]:
        return self.boxes

    # --------------------------- sinh lân cận --------------------------

    def get_neighbors(self) -> List["State"]:
        """
        Trả về danh sách trạng thái kề theo thứ tự U, D, L, R.
        Cache lần đầu để tránh tạo lại khi đã expand nút này.
        """
        if self._neighbors_cache is not None:
            return list(self._neighbors_cache)

        res: List[State] = []
        x, y = self.player.get_x(), self.player.get_y()
        self._try_move(res, x - 1, y, x - 2, y, "u")  # Up
        self._try_move(res, x + 1, y, x + 2, y, "d")  # Down
        self._try_move(res, x, y - 1, x, y - 2, "l")  # Left
        self._try_move(res, x, y + 1, x, y + 2, "r")  # Right
        self._neighbors_cache = res
        return res

    def _try_move(self, out: List["State"], ax: int, ay: int, bx: int, by: int, m: str) -> None:
        """
        Player thử bước sang (ax,ay). Nếu đó là hộp, hộp bị đẩy sang (bx,by).

        Hợp lệ khi:
          - (ax,ay) trong biên và không phải tường
          - Nếu (ax,ay) là box thì (bx,by) trong biên, không tường/không box,
            và KHÔNG thuộc deadlocks.
        """
        # Kiểm tra biên cho cả ô người đứng và ô đẩy box
        if not self.inbound(ax, ay):
            return
        if (ax, ay) in ((w.get_x(), w.get_y()) for w in self.walls):
            return

        attempt = Point(ax, ay)

        # Nếu là ô trống → bước thường
        if attempt not in self.boxes:
            out.append(
                State(
                    self.walls, self.boxes, self.storages,
                    attempt, self.move + m,
                    self.rows, self.cols, self.verbose, self.deadlocks,
                )
            )
            return

        # Nếu là hộp → đẩy sang (bx,by)
        if not self.inbound(bx, by):
            return
        newbox = Point(bx, by)
        if (newbox in self.walls) or (newbox in self.boxes):
            return
        if newbox in self.deadlocks:
            # Chặn sớm nhánh vô vọng
            return

        new_boxes = set(self.boxes)
        new_boxes.remove(attempt)
        new_boxes.add(newbox)

        out.append(
            State(
                self.walls, new_boxes, self.storages,
                attempt, self.move + m,
                self.rows, self.cols, self.verbose, self.deadlocks,
            )
        )

    # ----------------------------- heuristic -----------------------------

    def manhatten(self) -> int:
        """
        Heuristic Manhattan (admissible):
          H = (player → box gần nhất) + Σ(box → goal gần nhất)
        """
        # player → box gần nhất
        if self.boxes:
            px, py = self.player.get_x(), self.player.get_y()
            p2b = min(abs(px - b.get_x()) + abs(py - b.get_y()) for b in self.boxes)
        else:
            p2b = 0

        # mỗi box → goal gần nhất
        goals: List[Tuple[int, int]] = [(g.get_x(), g.get_y()) for g in self.storages]
        b2g = 0
        for b in self.boxes:
            bx, by = b.get_x(), b.get_y()
            b2g += min(abs(bx - gx) + abs(by - gy) for gx, gy in goals)

        return p2b + b2g

    def euclidean(self) -> float:
        """
        Heuristic Euclid: tương tự manhattan nhưng dùng sqrt.
        Chủ yếu để so sánh; trong grid 4 hướng, manhattan thường tốt hơn.
        """
        from math import hypot
        if self.boxes:
            px, py = self.player.get_x(), self.player.get_y()
            p2b = min(hypot(px - b.get_x(), py - b.get_y()) for b in self.boxes)
        else:
            p2b = 0.0

        goals: List[Tuple[int, int]] = [(g.get_x(), g.get_y()) for g in self.storages]
        b2g = 0.0
        for b in self.boxes:
            bx, by = b.get_x(), b.get_y()
            b2g += min(hypot(bx - gx, by - gy) for gx, gy in goals)

        return p2b + b2g

    # --------------------------- hash / equality --------------------------

    def __hash__(self) -> int:
        """
        Hash ổn định theo (vị trí player, tập boxes đã sort).
        Dùng tuple sorted để đảm bảo thứ tự không ảnh hưởng kết quả.
        """
        boxes_sorted = tuple(sorted((b.get_x(), b.get_y()) for b in self.boxes))
        return hash((self.player.get_x(), self.player.get_y(), boxes_sorted))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, State)
            and self.player == other.player
            and self.boxes == other.boxes
        )

    # ------------------------------- debug --------------------------------

    def load_map(self) -> None:
        """Dựng mảng ký tự để in debug khi cần (không dùng cho UI)."""
        self.map = [[' ' for _ in range(self.cols)] for _ in range(self.rows)]
        for e in self.walls:
            self.map[e.get_x() - 1][e.get_y() - 1] = '#'
        for e in self.storages:
            self.map[e.get_x() - 1][e.get_y() - 1] = '.'
        for e in self.boxes:
            self.map[e.get_x() - 1][e.get_y() - 1] = '$'
        self.map[self.player.get_x() - 1][self.player.get_y() - 1] = '@'

    def print_map(self) -> None:
        for row in getattr(self, "map", []):
            print(' '.join(row))

    def __repr__(self) -> str:
        return f"State(player=({self.player.get_x()},{self.player.get_y()}), boxes={len(self.boxes)}, move='{self.move}')"

File ui.py
# -*- coding: utf-8 -*-
"""
Sokoban Solver Visualizer (UI)
Hotkeys:
  • ↑/↓: chuyển mục focus (Algorithm / Map / Solve / Back)
  • ←/→: đổi Algorithm (BFS/A*) hoặc đổi Map
  • Enter:
      - Ở mục Map: chuyển sang map kế tiếp (không auto-solve)
      - Ở mục Solve: bắt đầu solve
      - Ở màn Finished: sang map kế tiếp & quay lại menu
  • S: Solve nhanh
  • R: Replay khi đang Running/Finished
  • Esc hoặc C: Cancel khi đang Solving…
  • B: Back về menu
"""

import os
import sys
import time
import threading
from typing import List, Optional

import pygame

# ---- Paths ----
SCREEN_W, SCREEN_H = 1200, 760
ASSET_DIR = os.path.join(os.path.dirname(__file__), "..", "assets")
MAP_DIR = os.path.join(os.path.dirname(__file__), "..", "formal_inputs")
FONT_PATH = os.path.join(ASSET_DIR, "NotoSans-Regular.ttf")

# ---- Visual config ----
FPS = 90
TILE = 50
ANIM_DELAY_MS = 120

# Theme (Gen-Z pastel + dark)
COL_BG = (17, 19, 23)
COL_PANEL = (30, 34, 40)
COL_CARD = (40, 46, 54)
COL_ACCENT = (78, 156, 255)     # primary
COL_ACCENT_2 = (120, 220, 160)  # success
COL_MUTED = (160, 168, 180)
COL_TEXT = (230, 232, 236)
COL_BAD = (230, 110, 110)
COL_BTN = (58, 110, 210)
COL_BTN_DARK = (42, 86, 172)
RADIUS = 14

# ---- Backend imports ----
from sokoban import Sokoban
from state import State
from search import Search
from deadlock_detector import DeadLockDetector
from point import Point

# ------------- Helpers -------------
def load_image(path):
    full = os.path.join(ASSET_DIR, path)
    if not os.path.isfile(full):
        return None
    try:
        return pygame.image.load(full).convert_alpha()
    except Exception:
        return None

def list_maps():
    if not os.path.isdir(MAP_DIR):
        return []
    files = [f for f in os.listdir(MAP_DIR) if f.endswith(".txt")]
    files.sort()
    return files

# ------------- Pygame init -------------
pygame.init()
pygame.key.set_repeat(220, 45)  # repeat: delay, interval (ms)
flags = pygame.SCALED
screen = pygame.display.set_mode((SCREEN_W, SCREEN_H), flags)
pygame.display.set_caption("Sokoban Solver Visualizer")

if os.path.isfile(FONT_PATH):
    font = pygame.font.Font(FONT_PATH, 18)
    font_big = pygame.font.Font(FONT_PATH, 30)
    font_mid = pygame.font.Font(FONT_PATH, 22)
else:
    font = pygame.font.SysFont(None, 18)
    font_big = pygame.font.SysFont(None, 30)
    font_mid = pygame.font.SysFont(None, 22)

# ---- Assets ----
img_bg = load_image("bg.png")
img_wall = load_image("wall.png")
img_box = load_image("box.png")
img_box_goal = load_image("box_goal.png")
img_player = load_image("player.png")
img_goal = load_image("goal.png")

def scale_tile(img, t):
    return pygame.transform.smoothscale(img, (t, t)) if img else None

# ------------- Board rendering -------------
def draw_board(surface, sokoban: Sokoban, area, tile=TILE):
    """area: pygame.Rect vị trí render board"""
    sokoban.load_map()
    h = sokoban.get_height()
    w = sokoban.get_width()

    # fit
    max_w = area.w
    max_h = area.h
    t = tile
    if w * t > max_w or h * t > max_h:
        t = max(16, min(max_w // max(1, w), max_h // max(1, h)))

    # center
    ox = area.x + (max_w - w * t) // 2
    oy = area.y + (max_h - h * t) // 2

    # tile-cache by size
    wall = scale_tile(img_wall, t)
    box = scale_tile(img_box, t)
    box_goal = scale_tile(img_box_goal, t)
    player = scale_tile(img_player, t)
    goal = scale_tile(img_goal, t)
    bg = scale_tile(img_bg, t)

    # background grid
    if bg:
        for i in range(h):
            for j in range(w):
                surface.blit(bg, (ox + j * t, oy + i * t))
    else:
        pygame.draw.rect(surface, (245, 246, 250), (ox, oy, w * t, h * t), border_radius=8)

    # walls
    for p in sokoban.get_walls():
        x = ox + (p.get_y() - 1) * t
        y = oy + (p.get_x() - 1) * t
        if wall:
            surface.blit(wall, (x, y))
        else:
            pygame.draw.rect(surface, (82, 86, 98), (x, y, t, t), border_radius=6)

    # goals
    goals = {(g.get_x(), g.get_y()) for g in sokoban.get_storages()}
    for gx, gy in goals:
        x = ox + (gy - 1) * t
        y = oy + (gx - 1) * t
        if goal:
            surface.blit(goal, (x, y))
        else:
            pygame.draw.circle(surface, (240, 205, 80), (x + t // 2, y + t // 2), max(4, t // 6))

    # boxes
    for b in sokoban.get_boxes():
        bx, by = b.get_x(), b.get_y()
        x = ox + (by - 1) * t
        y = oy + (bx - 1) * t
        if (bx, by) in goals and box_goal:
            surface.blit(box_goal, (x, y))
        elif box:
            surface.blit(box, (x, y))
        else:
            pygame.draw.rect(surface, (180, 140, 90), (x, y, t, t), border_radius=6)

    # player
    p = sokoban.get_player()
    x = ox + (p.get_y() - 1) * t
    y = oy + (p.get_x() - 1) * t
    if player:
        surface.blit(player, (x, y))
    else:
        pygame.draw.rect(surface, (72, 160, 255), (x + 3, y + 3, t - 6, t - 6), border_radius=6)

# ------------- Movement -------------
DIRS = {"u": (-1, 0), "d": (1, 0), "l": (0, -1), "r": (0, 1),
        "U": (-1, 0), "D": (1, 0), "L": (0, -1), "R": (0, 1)}

def apply_move_to_sokoban(sokoban: Sokoban, mv: str) -> bool:
    dx, dy = DIRS.get(mv, (0, 0))
    player = sokoban.get_player()
    px, py = player.get_x(), player.get_y()
    ax, ay = px + dx, py + dy

    walls = {(w.get_x(), w.get_y()) for w in sokoban.get_walls()}
    boxes = {(b.get_x(), b.get_y()) for b in sokoban.get_boxes()}

    if (ax, ay) in walls:
        return False
    if (ax, ay) in boxes:
        bx2, by2 = ax + dx, ay + dy
        if (bx2, by2) in walls or (bx2, by2) in boxes:
            return False
        new_boxes = set()
        for b in sokoban.get_boxes():
            if (b.get_x(), b.get_y()) == (ax, ay):
                new_boxes.add(Point(bx2, by2))
            else:
                new_boxes.add(Point(b.get_x(), b.get_y()))
        sokoban.set_boxes(new_boxes)

    sokoban.set_player(Point(ax, ay))
    sokoban.load_map()
    return True

# ------------- UI widgets -------------
def draw_panel(rect, title=None):
    pygame.draw.rect(screen, COL_PANEL, rect, border_radius=RADIUS)
    if title:
        txt = font_big.render(title, True, COL_TEXT)
        screen.blit(txt, (rect.x + 16, rect.y + 10))

def draw_button(rect, label, active=True, focused=False):
    col = COL_BTN if active else (60, 64, 72)
    if focused:
        # subtle glow
        pygame.draw.rect(screen, (90, 120, 220), rect.inflate(10, 10), border_radius=RADIUS)
    pygame.draw.rect(screen, col, rect, border_radius=RADIUS)
    t = font_mid.render(label, True, (255, 255, 255))
    screen.blit(t, (rect.centerx - t.get_width() // 2, rect.centery - t.get_height() // 2))

def draw_selector(rect, label, value, focused=False):
    pygame.draw.rect(screen, COL_CARD, rect, border_radius=RADIUS)
    l = font_mid.render(label, True, COL_MUTED)
    v = font_mid.render(value, True, COL_TEXT if not focused else COL_ACCENT)
    screen.blit(l, (rect.x + 14, rect.y + 10))
    screen.blit(v, (rect.x + 14, rect.y + 38))
    # arrows
    arw = "◀", "▶"
    aL = font_mid.render(arw[0], True, COL_MUTED)
    aR = font_mid.render(arw[1], True, COL_MUTED)
    screen.blit(aL, (rect.right - 70, rect.y + 36))
    screen.blit(aR, (rect.right - 34, rect.y + 36))

def draw_info(rect, info_lines):
    pygame.draw.rect(screen, COL_CARD, rect, border_radius=RADIUS)
    y = rect.y + 12
    for line, col in info_lines:
        t = font_mid.render(line, True, col)
        screen.blit(t, (rect.x + 14, y))
        y += t.get_height() + 6

# spinner overlay
def draw_spinner_overlay(text_top="Solving...", text_bottom="BFS/A* đang chạy ở nền, vui lòng chờ.", alpha=180, t=0.0):
    overlay = pygame.Surface((SCREEN_W, SCREEN_H), pygame.SRCALPHA)
    overlay.fill((0, 0, 0, alpha))
    screen.blit(overlay, (0, 0))

    # center texts
    tt = font_big.render(text_top, True, (235, 235, 240))
    tb = font_mid.render(text_bottom, True, (220, 220, 228))
    cx, cy = SCREEN_W // 2, SCREEN_H // 2

    # spinner (12 dots)
    R = 36
    n = 12
    for i in range(n):
        ang = (t * 4.0 + i) / n * 6.28318
        x = cx + int(R * 1.1 * pygame.math.Vector2(1, 0).rotate_rad(ang).x)
        y = cy + int(R * 1.1 * pygame.math.Vector2(1, 0).rotate_rad(ang).y)
        k = (i + (t * 12) % n) % n / (n - 1)
        col = (120 + int(80 * k), 170 + int(50 * k), 255)
        pygame.draw.circle(screen, col, (x, y), 5)

    screen.blit(tt, (cx - tt.get_width() // 2, cy - 70))
    screen.blit(tb, (cx - tb.get_width() // 2, cy + 40))

# ------------- Main -------------
def main():
    clock = pygame.time.Clock()

    # state
    maps = list_maps()
    map_index = 0 if maps else -1
    algo_list = ["BFS", "A*"]
    algo_index = 1  # default A*
    focus = 0       # 0: algo, 1: map, 2: solve, 3: back

    scene = "menu"  # menu | solving | running | finished
    sokoban: Optional[Sokoban] = None
    moves: List[str] = []
    move_idx = 0
    elapsed_ms = 0.0
    solved = False

    # solving thread
    solving = False
    cancel_evt = threading.Event()
    solver_thread: Optional[threading.Thread] = None
    solver_done = False
    solver_result: List[str] = []
    solver_elapsed = 0.0

    search = Search(False)

    # layout
    board_rect = pygame.Rect(20, 20, 760, 720)
    side_rect = pygame.Rect(800, 20, 380, 720)

    sel_algo = pygame.Rect(side_rect.x + 16, side_rect.y + 60, side_rect.w - 32, 90)
    sel_map = pygame.Rect(side_rect.x + 16, side_rect.y + 160, side_rect.w - 32, 90)
    info_rect = pygame.Rect(side_rect.x + 16, side_rect.y + 270, side_rect.w - 32, 210)

    btn_solve = pygame.Rect(side_rect.x + 16, side_rect.bottom - 120, 150, 48)
    btn_back = pygame.Rect(side_rect.right - 16 - 150, side_rect.bottom - 120, 150, 48)
    btn_replay = pygame.Rect(side_rect.right - 16 - 150, side_rect.bottom - 60, 150, 48)

    def current_map_path():
        return os.path.join(MAP_DIR, maps[map_index]) if (0 <= map_index < len(maps)) else None

    def load_preview():
        if map_index < 0 or map_index >= len(maps):
            return None
        try:
            s = Sokoban(current_map_path())
            s.load_map()
            return s
        except Exception:
            return None

    preview = load_preview()

    def cycle_map(delta):
        nonlocal map_index, preview
        if not maps:
            return
        map_index = (map_index + delta) % len(maps)
        preview = load_preview()

    def cycle_algo(delta):
        nonlocal algo_index
        algo_index = (algo_index + delta) % len(algo_list)

    def start_solve():
        nonlocal solving, solver_thread, cancel_evt, solver_done, solver_result, solver_elapsed, scene, elapsed_ms
        if map_index < 0 or map_index >= len(maps):
            return
        try:
            sk = Sokoban(current_map_path())
            detector = DeadLockDetector(sk)
            deadlocks = detector.get_deadlock()
            root = State(sk.get_walls(), sk.get_boxes(), sk.get_storages(), sk.get_player(),
                         "", sk.get_height(), sk.get_width(), False, deadlocks)

            cancel_evt.clear()
            solver_done = False
            solver_result = []
            solver_elapsed = 0.0

            def _worker():
                nonlocal solver_result, solver_elapsed, solver_done
                t0 = time.time()
                if algo_list[algo_index] == "BFS":
                    solver_result = search.bfs_return_path(root, stop_cb=cancel_evt.is_set)
                else:
                    solver_result = search.astar_return_path(root, "manhatten", stop_cb=cancel_evt.is_set)
                solver_elapsed = (time.time() - t0) * 1000.0
                solver_done = True

            solver_thread = threading.Thread(target=_worker, daemon=True)
            solver_thread.start()
            solving = True
            scene = "solving"
        except Exception as ex:
            print("Load map error:", ex)

    def apply_solution_and_run():
        nonlocal sokoban, moves, move_idx, elapsed_ms, solved, scene
        sokoban = Sokoban(current_map_path())
        sokoban.load_map()
        moves = list(solver_result)
        move_idx = 0
        elapsed_ms = solver_elapsed
        solved = False
        scene = "running"

    # main loop
    t_spin = 0.0
    running = True
    while running:
        dt = clock.tick(FPS) / 1000.0
        t_spin += dt

        # handle solver completion
        if scene == "solving" and solving:
            if cancel_evt.is_set():
                solving = False
                scene = "menu"
            elif solver_done:
                solving = False
                if solver_result:
                    apply_solution_and_run()
                else:
                    # canceled hoặc không có lời giải
                    scene = "menu"

        for ev in pygame.event.get():
            if ev.type == pygame.QUIT:
                running = False
            elif ev.type == pygame.KEYDOWN:
                # global
                if ev.key == pygame.K_ESCAPE:
                    if scene == "solving":
                        cancel_evt.set()
                    elif scene in ("running", "finished"):
                        scene = "menu"
                # menu interactions
                if scene == "menu":
                    if ev.key == pygame.K_UP:
                        focus = (focus - 1) % 4
                    elif ev.key == pygame.K_DOWN:
                        focus = (focus + 1) % 4
                    elif ev.key == pygame.K_LEFT:
                        if focus == 0:
                            cycle_algo(-1)
                        elif focus == 1:
                            cycle_map(-1)
                    elif ev.key == pygame.K_RIGHT:
                        if focus == 0:
                            cycle_algo(1)
                        elif focus == 1:
                            cycle_map(1)
                    elif ev.key == pygame.K_RETURN:
                        if focus == 1:
                            cycle_map(1)  # enter trên map = next map (không auto-solve)
                        elif focus == 2:
                            start_solve()  # enter trên Solve => solve
                    elif ev.key == pygame.K_s:
                        start_solve()
                    elif ev.key == pygame.K_b:
                        preview = load_preview()  # refresh
                elif scene == "solving":
                    if ev.key in (pygame.K_c, pygame.K_ESCAPE):
                        cancel_evt.set()
                elif scene == "running":
                    if ev.key == pygame.K_r:
                        # replay
                        if map_index >= 0:
                            sokoban = Sokoban(current_map_path())
                            sokoban.load_map()
                            move_idx = 0
                            solved = False
                    elif ev.key == pygame.K_b:
                        scene = "menu"
                elif scene == "finished":
                    if ev.key == pygame.K_r:
                        # replay từ đầu
                        if map_index >= 0:
                            sokoban = Sokoban(current_map_path())
                            sokoban.load_map()
                            move_idx = 0
                            solved = False
                            scene = "running"
                    elif ev.key == pygame.K_RETURN:
                        # next map, quay lại menu
                        cycle_map(1)
                        scene = "menu"
                    elif ev.key == pygame.K_b:
                        scene = "menu"

            elif ev.type == pygame.MOUSEBUTTONDOWN:
                mx, my = ev.pos
                if scene == "menu":
                    if sel_algo.collidepoint(mx, my):
                        focus = 0
                    elif sel_map.collidepoint(mx, my):
                        focus = 1
                    elif btn_solve.collidepoint(mx, my):
                        focus = 2
                        start_solve()
                    elif btn_back.collidepoint(mx, my):
                        focus = 3
                        preview = load_preview()
                elif scene in ("running", "finished"):
                    if btn_back.collidepoint(mx, my):
                        scene = "menu"
                    elif btn_replay.collidepoint(mx, my):
                        if map_index >= 0:
                            sokoban = Sokoban(current_map_path())
                            sokoban.load_map()
                            move_idx = 0
                            solved = False
                            scene = "running"

        # --- update running animation ---
        if scene == "running" and sokoban is not None:
            if move_idx < len(moves):
                if (pygame.time.get_ticks() >= move_idx * ANIM_DELAY_MS):
                    mv = moves[move_idx]
                    apply_move_to_sokoban(sokoban, mv)
                    move_idx += 1
            else:
                # check goal
                goals = {(g.get_x(), g.get_y()) for g in sokoban.get_storages()}
                solved = all((b.get_x(), b.get_y()) in goals for b in sokoban.get_boxes())
                scene = "finished"

        # --- draw ---
        screen.fill(COL_BG)

        # board card
        pygame.draw.rect(screen, COL_PANEL, board_rect, border_radius=RADIUS)
        inner = board_rect.inflate(-24, -24)
        pygame.draw.rect(screen, (26, 28, 34), inner, border_radius=RADIUS)

        # right panel
        draw_panel(side_rect, "Sokoban Solver")

        # content
        if scene in ("menu", "solving"):
            # preview board
            if preview:
                draw_board(screen, preview, inner)
        else:
            if sokoban:
                draw_board(screen, sokoban, inner)

        # selectors + info
        algo_val = algo_list[algo_index]
        map_val = maps[map_index] if maps else "(no maps)"
        draw_selector(sel_algo, "Algorithm", algo_val, focused=(scene == "menu" and focus == 0))
        draw_selector(sel_map, "Map", map_val, focused=(scene == "menu" and focus == 1))

        # info block
        info = []
        info.append((f"Map:  {map_val}", COL_TEXT))
        info.append((f"Algo: {algo_val}", COL_TEXT))
        if scene in ("running", "finished"):
            info.append((f"Step: {min(move_idx, len(moves))}/{len(moves)}", COL_TEXT))
            info.append((f"Time (ms): {elapsed_ms:.2f}", COL_TEXT))
            if scene == "finished":
                info.append(("SOLVED!" if solved else "FAILED", COL_ACCENT_2 if solved else COL_BAD))
        draw_info(info_rect, info)

        # buttons
        if scene == "menu":
            draw_button(btn_solve, "Solve (S)", focused=(focus == 2))
            draw_button(btn_back, "Back", focused=(focus == 3))
        else:
            draw_button(btn_back, "Back", active=True, focused=False)
            draw_button(btn_replay, "Replay (R)", active=True, focused=False)

        # solving overlay
        if scene == "solving":
            draw_spinner_overlay(t=t_spin)

        pygame.display.flip()

    pygame.quit()


if __name__ == "__main__":
    main()


